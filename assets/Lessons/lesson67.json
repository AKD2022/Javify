{
  "lessonId": 67,
  "title": "Practice with Nested Loops",
  "content": [
    {
      "type": "text",
      "value": "Nested loops are loops contained within other loops, creating a powerful pattern for problems that require multiple levels of iteration. When an outer loop completes one iteration, the inner loop executes completely before the outer loop advances. Understanding how nested loops behave is crucial for working with two-dimensional arrays, generating patterns, and solving complex algorithmic problems."
    },
    {
      "type": "text",
      "value": "The most fundamental nested loop structure has an outer "
    },
    {
      "type": "code",
      "value": "for"
    },
    {
      "type": "text",
      "value": " loop controlling iteration over rows and an inner "
    },
    {
      "type": "code",
      "value": "for"
    },
    {
      "type": "text",
      "value": " loop controlling iteration over columns or elements within each row."
    },
    {
      "type": "code",
      "value": "for (int i = 1; i <= 3; i++) {\n    for (int j = 1; j <= 2; j++) {\n        System.out.print(i + \"-\" + j + \" \");\n    }\n    System.out.println();\n}"
    },
    {
      "type": "text",
      "value": "This nested loop prints each combination of "
    },
    {
      "type": "code",
      "value": "i"
    },
    {
      "type": "text",
      "value": " and "
    },
    {
      "type": "code",
      "value": "j"
    },
    {
      "type": "text",
      "value": ". For each value of "
    },
    {
      "type": "code",
      "value": "i"
    },
    {
      "type": "text",
      "value": " from 1 to 3, the inner loop completes all iterations of "
    },
    {
      "type": "code",
      "value": "j"
    },
    {
      "type": "text",
      "value": " from 1 to 2. The output shows: 1-1 1-2 on the first line, 2-1 2-2 on the second line, and 3-1 3-2 on the third line."
    },
    {
      "type": "text",
      "value": "Two-dimensional arrays naturally pair with nested loops. The outer loop iterates through rows while the inner loop iterates through columns within each row."
    },
    {
      "type": "code",
      "value": "int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n\nfor (int row = 0; row < matrix.length; row++) {\n    for (int col = 0; col < matrix[row].length; col++) {\n        System.out.print(matrix[row][col] + \" \");\n    }\n    System.out.println();\n}"
    },
    {
      "type": "text",
      "value": "The outer loop variable "
    },
    {
      "type": "code",
      "value": "row"
    },
    {
      "type": "text",
      "value": " accesses "
    },
    {
      "type": "code",
      "value": "matrix.length"
    },
    {
      "type": "text",
      "value": " to iterate through all rows. The inner loop variable "
    },
    {
      "type": "code",
      "value": "col"
    },
    {
      "type": "text",
      "value": " accesses "
    },
    {
      "type": "code",
      "value": "matrix[row].length"
    },
    {
      "type": "text",
      "value": " to access the number of columns in the current row. This prints the matrix row by row."
    },
    {
      "type": "text",
      "value": "Understanding nested loop execution order is essential. The inner loop completes entirely before the outer loop advances. Each iteration of the outer loop triggers the entire execution of the inner loop."
    },
    {
      "type": "code",
      "value": "for (int i = 0; i < 2; i++) {\n    System.out.println(\"Outer: \" + i);\n    for (int j = 0; j < 3; j++) {\n        System.out.println(\"  Inner: \" + j);\n    }\n}"
    },
    {
      "type": "text",
      "value": "The execution order shows: Outer: 0, then all inner iterations (0, 1, 2), then Outer: 1, then all inner iterations again (0, 1, 2). The inner loop \"resets\" for each outer loop iteration, with "
    },
    {
      "type": "code",
      "value": "j"
    },
    {
      "type": "text",
      "value": " starting back at 0 each time."
    },
    {
      "type": "text",
      "value": "Creating visual patterns demonstrates a practical use of nested loops. Generating shapes like rectangles, triangles, or grids requires careful control of nested loop boundaries."
    },
    {
      "type": "code",
      "value": "for (int i = 0; i < 4; i++) {\n    for (int j = 0; j < 5; j++) {\n        System.out.print(\"* \");\n    }\n    System.out.println();\n}"
    },
    {
      "type": "text",
      "value": "This nested loop creates a 4 by 5 rectangle of asterisks. The outer loop controls 4 rows, and the inner loop prints 5 asterisks on each row."
    },
    {
      "type": "text",
      "value": "Triangular patterns require the inner loop's boundary to depend on the outer loop variable."
    },
    {
      "type": "code",
      "value": "for (int i = 1; i <= 5; i++) {\n    for (int j = 0; j < i; j++) {\n        System.out.print(\"* \");\n    }\n    System.out.println();\n}"
    },
    {
      "type": "text",
      "value": "Here, when "
    },
    {
      "type": "code",
      "value": "i"
    },
    {
      "type": "text",
      "value": " is 1, the inner loop runs once. When "
    },
    {
      "type": "code",
      "value": "i"
    },
    {
      "type": "text",
      "value": " is 2, the inner loop runs twice. This dependency creates a growing triangle with 1 star on line 1, 2 stars on line 2, 3 stars on line 3, and so on."
    },
    {
      "type": "text",
      "value": "Searching within a two-dimensional structure requires nested loops to check each position. For example, finding a specific value in a matrix requires examining each element."
    },
    {
      "type": "code",
      "value": "int[][] grid = {{5, 12, 8}, {3, 7, 15}, {9, 2, 11}};\nint target = 7;\nboolean found = false;\n\nfor (int i = 0; i < grid.length && !found; i++) {\n    for (int j = 0; j < grid[i].length && !found; j++) {\n        if (grid[i][j] == target) {\n            System.out.println(\"Found \" + target + \" at (\" + i + \", \" + j + \")\");\n            found = true;\n        }\n    }\n}"
    },
    {
      "type": "text",
      "value": "This nested loop searches through each position of the matrix. The boolean flag "
    },
    {
      "type": "code",
      "value": "found"
    },
    {
      "type": "text",
      "value": " prevents unnecessary searching after the target is located. Notice how "
    },
    {
      "type": "code",
      "value": "!found"
    },
    {
      "type": "text",
      "value": " is included in both loop conditions to exit as soon as the value is found."
    },
    {
      "type": "text",
      "value": "Accumulating values across a two-dimensional structure uses nested loops with an accumulator variable. For example, calculating the sum of all elements in a matrix requires visiting every position."
    },
    {
      "type": "code",
      "value": "int[][] numbers = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\nint sum = 0;\n\nfor (int i = 0; i < numbers.length; i++) {\n    for (int j = 0; j < numbers[i].length; j++) {\n        sum += numbers[i][j];\n    }\n}\n\nSystem.out.println(\"Total sum: \" + sum);"
    },
    {
      "type": "text",
      "value": "The accumulator "
    },
    {
      "type": "code",
      "value": "sum"
    },
    {
      "type": "text",
      "value": " is declared outside both loops, allowing it to persist across all iterations. Each nested loop iteration adds another element to the running total. The sum of all elements is 45."
    },
    {
      "type": "text",
      "value": "Counting elements meeting specific criteria in a two-dimensional array uses nested loops with a counter."
    },
    {
      "type": "code",
      "value": "int[][] data = {{12, 5, 8}, {20, 3, 15}, {7, 11, 9}};\nint evenCount = 0;\n\nfor (int i = 0; i < data.length; i++) {\n    for (int j = 0; j < data[i].length; j++) {\n        if (data[i][j] % 2 == 0) {\n            evenCount++;\n        }\n    }\n}\n\nSystem.out.println(\"Even numbers found: \" + evenCount);"
    },
    {
      "type": "text",
      "value": "The counter "
    },
    {
      "type": "code",
      "value": "evenCount"
    },
    {
      "type": "text",
      "value": " increments each time an even number is encountered. The condition "
    },
    {
      "type": "code",
      "value": "data[i][j] % 2 == 0"
    },
    {
      "type": "text",
      "value": " identifies even numbers throughout the matrix."
    },
    {
      "type": "text",
      "value": "Finding row or column totals in a matrix requires careful use of the accumulator. The accumulator should reset for each row when calculating row sums."
    },
    {
      "type": "code",
      "value": "int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n\nfor (int i = 0; i < matrix.length; i++) {\n    int rowSum = 0;\n    for (int j = 0; j < matrix[i].length; j++) {\n        rowSum += matrix[i][j];\n    }\n    System.out.println(\"Row \" + i + \" sum: \" + rowSum);\n}"
    },
    {
      "type": "text",
      "value": "The accumulator "
    },
    {
      "type": "code",
      "value": "rowSum"
    },
    {
      "type": "text",
      "value": " is declared inside the outer loop, causing it to reset to 0 for each new row. This prints the sum for each row: Row 0 sum: 6, Row 1 sum: 15, Row 2 sum: 24."
    },
    {
      "type": "text",
      "value": "Column sums require a different approach where the accumulator persists across outer loop iterations."
    },
    {
      "type": "code",
      "value": "int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\nint[] columnSums = new int[matrix[0].length];\n\nfor (int i = 0; i < matrix.length; i++) {\n    for (int j = 0; j < matrix[i].length; j++) {\n        columnSums[j] += matrix[i][j];\n    }\n}\n\nfor (int j = 0; j < columnSums.length; j++) {\n    System.out.println(\"Column \" + j + \" sum: \" + columnSums[j]);\n}"
    },
    {
      "type": "text",
      "value": "This approach creates an array "
    },
    {
      "type": "code",
      "value": "columnSums"
    },
    {
      "type": "text",
      "value": " to track each column's total. The nested loops accumulate values into each column's position. Column 0 sums to 12, column 1 to 15, and column 2 to 18."
    },
    {
      "type": "text",
      "value": "Comparing elements between different positions often uses nested loops. For instance, checking if a matrix is symmetric requires comparing each element with its mirror position."
    },
    {
      "type": "code",
      "value": "int[][] matrix = {{1, 2, 3}, {2, 5, 6}, {3, 6, 9}};\nboolean isSymmetric = true;\n\nfor (int i = 0; i < matrix.length && isSymmetric; i++) {\n    for (int j = 0; j < matrix[i].length && isSymmetric; j++) {\n        if (matrix[i][j] != matrix[j][i]) {\n            isSymmetric = false;\n        }\n    }\n}\n\nSystem.out.println(\"Symmetric: \" + isSymmetric);"
    },
    {
      "type": "text",
      "value": "This algorithm compares "
    },
    {
      "type": "code",
      "value": "matrix[i][j]"
    },
    {
      "type": "text",
      "value": " with "
    },
    {
      "type": "code",
      "value": "matrix[j][i]"
    },
    {
      "type": "text",
      "value": " (the transposed position). If any pair doesn't match, the matrix isn't symmetric and the boolean flag stops further checking."
    },
    {
      "type": "text",
      "value": "Three levels of nesting can occur with three-dimensional arrays, though they're less common in introductory courses. Each additional nested level multiplies the total iterations."
    },
    {
      "type": "code",
      "value": "int[][][] cube = {{{1, 2}, {3, 4}}, {{5, 6}, {7, 8}}};\n\nfor (int i = 0; i < cube.length; i++) {\n    for (int j = 0; j < cube[i].length; j++) {\n        for (int k = 0; k < cube[i][j].length; k++) {\n            System.out.print(cube[i][j][k] + \" \");\n        }\n    }\n}"
    },
    {
      "type": "text",
      "value": "With three nested loops, each level represents a different dimension. The outermost loop iterates through \"planes,\" the middle loop through rows, and the innermost through columns."
    },
    {
      "type": "text",
      "value": "Common mistakes with nested loops include forgetting to reset accumulators or counters, using the same variable name in both loops (which causes errors), or misunderstanding when inner loops reset."
    },
    {
      "type": "code",
      "value": "// INCORRECT - same variable name in both loops\nfor (int i = 0; i < 3; i++) {\n    for (int i = 0; i < 2; i++) {  // Error: i already declared\n        System.out.print(i + \" \");\n    }\n}\n\n// CORRECT - different variable names\nfor (int i = 0; i < 3; i++) {\n    for (int j = 0; j < 2; j++) {  // Different variable name\n        System.out.print(j + \" \");\n    }\n}"
    },
    {
      "type": "text",
      "value": "Java requires unique variable names within scope. Using the same variable name in nested loops causes a compilation error. Always use different variable names for different loop levels."
    },
    {
      "type": "text",
      "value": "Efficiency matters with nested loops. An outer loop executing "
    },
    {
      "type": "code",
      "value": "n"
    },
    {
      "type": "text",
      "value": " times and an inner loop executing "
    },
    {
      "type": "code",
      "value": "m"
    },
    {
      "type": "text",
      "value": " times results in "
    },
    {
      "type": "code",
      "value": "n * m"
    },
    {
      "type": "text",
      "value": " total inner loop executions. With large arrays, this can become slow. As you advance, you'll learn about optimizations and when to avoid nested loops."
    },
    {
      "type": "text",
      "value": "Mastering nested loops opens doors to solving complex problems involving multi-dimensional data. Whether working with matrices, performing comparisons across multiple collections, or generating patterns, nested loops are fundamental tools. Practice with different nesting patterns, different loop boundaries, and different operations to build intuition for when and how to apply them."
    }
  ]
}