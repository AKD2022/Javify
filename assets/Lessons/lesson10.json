{
  "lessonId": 10,
  "title": "Operator Precedence and Parentheses",
  "content": [
    {
      "type": "text",
      "value": "Operator precedence determines the order in which operations are performed in complex expressions. Understanding these rules is crucial for writing correct mathematical expressions and avoiding subtle bugs that can arise from unexpected evaluation order."
    },
    {
      "type": "text",
      "value": "Java follows mathematical conventions for operator precedence, but with additional rules for programming-specific operations. When multiple operators appear in an expression, Java evaluates them according to a hierarchy where some operators have higher priority than others."
    },
    {
      "type": "text",
      "value": "The precedence hierarchy from highest to lowest includes: parentheses ("
    },
    {
      "type": "code",
      "value": "()"
    },
    {
      "type": "text",
      "value": "), unary operators ("
    },
    {
      "type": "code",
      "value": "++"
    },
    {
      "type": "text",
      "value": ", "
    },
    {
      "type": "code",
      "value": "--"
    },
    {
      "type": "text",
      "value": ", "
    },
    {
      "type": "code",
      "value": "!"
    },
    {
      "type": "text",
      "value": "), multiplicative operators ("
    },
    {
      "type": "code",
      "value": "*"
    },
    {
      "type": "text",
      "value": ", "
    },
    {
      "type": "code",
      "value": "/"
    },
    {
      "type": "text",
      "value": ", "
    },
    {
      "type": "code",
      "value": "%"
    },
    {
      "type": "text",
      "value": "), and additive operators ("
    },
    {
      "type": "code",
      "value": "+"
    },
    {
      "type": "text",
      "value": ", "
    },
    {
      "type": "code",
      "value": "-"
    },
    {
      "type": "text",
      "value": ")."
    },
    {
      "type": "code",
      "value": "int result1 = 2 + 3 * 4;      // 14, not 20 (* before +)\nint result2 = 15 - 8 / 2;     // 11, not 3.5 (/ before -)\nint result3 = 10 % 3 + 5;     // 6, not 0 (% before +)"
    },
    {
      "type": "text",
      "value": "Parentheses have the highest precedence and force evaluation of their contents first, regardless of other operator precedence rules. Nested parentheses are evaluated from innermost to outermost."
    },
    {
      "type": "code",
      "value": "int withParens = (2 + 3) * 4;     // 20 (parentheses force addition first)\nint nested = ((8 - 2) * 3) + 1;   // 19 (innermost first: 6 * 3 + 1)\nint complex = (10 + (4 * 2)) / 6; // 3 (inner: 4*2=8, then 10+8=18, then 18/6=3)"
    },
    {
      "type": "text",
      "value": "When operators have equal precedence, Java uses left-to-right associativity. This means operations of the same precedence level are evaluated from left to right, which is important for operations like subtraction and division."
    },
    {
      "type": "code",
      "value": "int leftRight1 = 20 - 8 - 3;     // (20 - 8) - 3 = 9, not 15\nint leftRight2 = 24 / 4 / 2;     // (24 / 4) / 2 = 3, not 12\nint leftRight3 = 2 * 3 * 4;      // (2 * 3) * 4 = 24"
    },
    {
      "type": "text",
      "value": "Unary operators like increment ("
    },
    {
      "type": "code",
      "value": "++"
    },
    {
      "type": "text",
      "value": "), decrement ("
    },
    {
      "type": "code",
      "value": "--"
    },
    {
      "type": "text",
      "value": "), and logical NOT ("
    },
    {
      "type": "code",
      "value": "!"
    },
    {
      "type": "text",
      "value": ") have higher precedence than binary arithmetic operators. They are evaluated before arithmetic operations unless parentheses dictate otherwise."
    },
    {
      "type": "code",
      "value": "int x = 5;\nint result1 = ++x * 2;        // 12 (x becomes 6, then 6 * 2)\nint result2 = 2 * ++x;        // 14 (x becomes 7, then 2 * 7)\nboolean result3 = !true && false; // false (!(true) && false)"
    },
    {
      "type": "text",
      "value": "The modulus operator ("
    },
    {
      "type": "code",
      "value": "%"
    },
    {
      "type": "text",
      "value": ") has the same precedence as multiplication and division. This can lead to unexpected results if you're not careful about the evaluation order in complex expressions."
    },
    {
      "type": "code",
      "value": "int mod1 = 17 % 5 + 3;        // 2 + 3 = 5 (% before +)\nint mod2 = 17 % (5 + 3);      // 17 % 8 = 1 (parentheses force addition first)\nint mod3 = 20 - 15 % 4;       // 20 - 3 = 17 (% before -)"
    },
    {
      "type": "text",
      "value": "Mixed arithmetic with different data types follows precedence rules first, then applies type promotion. The precedence determines which operations happen first, and then Java promotes types as needed for each operation."
    },
    {
      "type": "code",
      "value": "double result1 = 5 + 3 * 2.0; // 5 + 6.0 = 11.0 (* first, then +)\nint result2 = (int)(5.5 + 3 * 2); // (int)(5.5 + 6) = (int)(11.5) = 11\ndouble result3 = 10 / 2 + 3.5; // 5 + 3.5 = 8.5 (/ first, then +)"
    },
    {
      "type": "text",
      "value": "Compound assignment operators ("
    },
    {
      "type": "code",
      "value": "+="
    },
    {
      "type": "text",
      "value": ", "
    },
    {
      "type": "code",
      "value": "-="
    },
    {
      "type": "text",
      "value": ", etc.) have very low precedence and are evaluated last. This means the right-hand side expression is completely evaluated before the assignment operation occurs."
    },
    {
      "type": "code",
      "value": "int x = 10;\nx += 2 * 3;          // x += 6; x becomes 16\nx *= 1 + 2;          // x *= 3; x becomes 48\nx /= 4 - 2;          // x /= 2; x becomes 24"
    },
    {
      "type": "text",
      "value": "When working with boolean expressions, logical operators have their own precedence rules. NOT ("
    },
    {
      "type": "code",
      "value": "!"
    },
    {
      "type": "text",
      "value": ") has higher precedence than AND ("
    },
    {
      "type": "code",
      "value": "&&"
    },
    {
      "type": "text",
      "value": "), which has higher precedence than OR ("
    },
    {
      "type": "code",
      "value": "||"
    },
    {
      "type": "text",
      "value": ")."
    },
    {
      "type": "code",
      "value": "boolean result1 = !true && false;    // false (!(true) && false)\nboolean result2 = true && false || true; // true ((true && false) || true)\nboolean result3 = !(true && false);  // true (!(false))"
    },
    {
      "type": "text",
      "value": "Comparison operators ("
    },
    {
      "type": "code",
      "value": "=="
    },
    {
      "type": "text",
      "value": ", "
    },
    {
      "type": "code",
      "value": "!="
    },
    {
      "type": "text",
      "value": ", "
    },
    {
      "type": "code",
      "value": "<"
    },
    {
      "type": "text",
      "value": ", "
    },
    {
      "type": "code",
      "value": ">"
    },
    {
      "type": "text",
      "value": ", etc.) have lower precedence than arithmetic operators but higher precedence than logical operators. This allows natural expression of mathematical comparisons."
    },
    {
      "type": "code",
      "value": "boolean result1 = 5 + 3 > 7;         // (5 + 3) > 7 = true\nboolean result2 = 10 / 2 == 5;        // (10 / 2) == 5 = true\nboolean result3 = x * 2 < y + 5;      // (x * 2) < (y + 5)"
    },
    {
      "type": "text",
      "value": "Best practices for handling precedence include using parentheses for clarity even when they're not strictly necessary, breaking complex expressions into simpler parts, and being explicit about your intentions to make code more maintainable."
    },
    {
      "type": "code",
      "value": "// Clear and explicit\ndouble average = (score1 + score2 + score3) / 3.0;\nboolean inRange = (value >= min) && (value <= max);\n\n// Break complex expressions into steps\nint numerator = a * b + c * d;\nint denominator = e + f;\ndouble result = (double) numerator / denominator;"
    },
    {
      "type": "text",
      "value": "Common precedence mistakes include assuming left-to-right evaluation for all operators, forgetting that modulus has the same precedence as multiplication and division, and not accounting for type promotion in mixed expressions."
    },
    {
      "type": "code",
      "value": "// Common mistakes and corrections\nint wrong = 10 - 4 - 2;        // 4, not 8\nint right = 10 - (4 + 2);      // 4 when you want 10 - 6\n\ndouble wrongDiv = 7 / 2 + 0.5; // 3.5, not 4.0\ndouble rightDiv = 7.0 / 2 + 0.5; // 4.0 when you want floating division"
    },
    {
      "type": "text",
      "value": "Understanding precedence helps you predict how Java will evaluate complex expressions and write code that behaves exactly as intended. When in doubt, use parentheses to make your intentions explicit and your code more readable."
    },
    {
      "type": "text",
      "value": "Mastering operator precedence and parentheses is essential for writing reliable mathematical expressions and boolean logic. In the next lesson, we'll explore constants and the "
    },
    {
      "type": "code",
      "value": "final"
    },
    {
      "type": "text",
      "value": " keyword for creating unchangeable values."
    }
  ]
}