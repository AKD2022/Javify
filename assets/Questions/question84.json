{
  "lessonId": 84,
  "title": "Common Mistakes with Classes and Objects",
  "questions": [
    {
      "id": 1,
      "type": "text",
      "question": "Can you call instance methods directly on the class name?",
      "options": [
        { "type": "text", "value": "No, you need an actual object instance" },
        { "type": "text", "value": "Yes, always" },
        { "type": "text", "value": "Only for constructors" },
        { "type": "text", "value": "Only for getters" }
      ],
      "answer": 0,
      "explanation": "Instance methods require an object; only static methods can be called directly on the class name."
    },
    {
      "id": 2,
      "type": "text",
      "question": "What happens if you forget to use new when creating an object?",
      "options": [
        { "type": "text", "value": "The object is created automatically" },
        { "type": "text", "value": "The reference remains null, causing NullPointerException when accessed" },
        { "type": "text", "value": "A default object is created" },
        { "type": "text", "value": "The compiler creates the object" }
      ],
      "answer": 1,
      "explanation": "Without new, the reference is declared but not initialized, remaining null and causing errors when accessed."
    },
    {
      "id": 3,
      "type": "text",
      "question": "What error occurs when calling methods on a null reference?",
      "options": [
        { "type": "text", "value": "CompileException" },
        { "type": "text", "value": "StackOverflowError" },
        { "type": "text", "value": "NullPointerException" },
        { "type": "text", "value": "OutOfMemoryError" }
      ],
      "answer": 2,
      "explanation": "Accessing methods or fields on a null reference throws NullPointerException at runtime."
    },
    {
      "id": 4,
      "type": "text",
      "question": "When should you use == vs equals() for objects?",
      "options": [
        { "type": "text", "value": "Always use ==" },
        { "type": "text", "value": "Always use equals()" },
        { "type": "text", "value": "They are identical" },
        { "type": "text", "value": "Use == for reference comparison, equals() for content comparison" }
      ],
      "answer": 3,
      "explanation": "Use == to check if references point to the same object; use equals() to compare object content."
    },
    {
      "id": 5,
      "type": "text",
      "question": "Why should instance variables be private?",
      "options": [
        { "type": "text", "value": "To enforce encapsulation and enable validation through getters/setters" },
        { "type": "text", "value": "To make code run faster" },
        { "type": "text", "value": "To prevent object creation" },
        { "type": "text", "value": "Private is not recommended" }
      ],
      "answer": 0,
      "explanation": "Private instance variables enforce encapsulation, allowing controlled access and validation through methods."
    },
    {
      "id": 6,
      "type": "text",
      "question": "What happens if you forget this when parameter names match instance variables?",
      "options": [
        { "type": "text", "value": "Nothing, it works fine" },
        { "type": "text", "value": "The parameter assigns to itself, leaving the instance variable uninitialized" },
        { "type": "text", "value": "Compilation error" },
        { "type": "text", "value": "The program crashes" }
      ],
      "answer": 1,
      "explanation": "Without this, the parameter shadows the instance variable, causing assignment to the parameter instead of the field."
    },
    {
      "id": 7,
      "type": "text",
      "question": "What happens if you add a return type to a constructor?",
      "options": [
        { "type": "text", "value": "It works normally" },
        { "type": "text", "value": "It becomes a constructor with return" },
        { "type": "text", "value": "It becomes a regular method, not a constructor" },
        { "type": "text", "value": "It creates two constructors" }
      ],
      "answer": 2,
      "explanation": "Adding a return type makes it a regular method instead of a constructor; constructors must have no return type."
    },
    {
      "id": 8,
      "type": "text",
      "question": "Should getters modify object state?",
      "options": [
        { "type": "text", "value": "Yes, always" },
        { "type": "text", "value": "Only for counters" },
        { "type": "text", "value": "Only in special cases" },
        { "type": "text", "value": "No, getters should only return values without side effects" }
      ],
      "answer": 3,
      "explanation": "Getters should return values without modifying state; side effects belong in setters or other mutator methods."
    },
    {
      "id": 9,
      "type": "text",
      "question": "What is the risk of returning mutable objects directly from getters?",
      "options": [
        { "type": "text", "value": "External code can modify internal state directly" },
        { "type": "text", "value": "No risk exists" },
        { "type": "text", "value": "It improves performance" },
        { "type": "text", "value": "It prevents null errors" }
      ],
      "answer": 0,
      "explanation": "Returning direct references to mutable objects allows external code to bypass encapsulation and modify internal state."
    },
    {
      "id": 10,
      "type": "text",
      "question": "When should you use static for class members?",
      "options": [
        { "type": "text", "value": "Always" },
        { "type": "text", "value": "For truly shared data or utility methods, not for instance-specific data" },
        { "type": "text", "value": "Never" },
        { "type": "text", "value": "Only for constructors" }
      ],
      "answer": 1,
      "explanation": "Reserve static for shared data or utility methods; most class members should be instance-specific."
    },
    {
      "id": 11,
      "type": "text",
      "question": "Why should you override toString()?",
      "options": [
        { "type": "text", "value": "It's required by Java" },
        { "type": "text", "value": "It makes debugging easier with readable output" },
        { "type": "text", "value": "It improves performance" },
        { "type": "text", "value": "It prevents errors" }
      ],
      "answer": 1,
      "explanation": "Overriding toString() provides readable output for debugging and displaying objects instead of cryptic memory addresses."
    },
    {
      "id": 12,
      "type": "text",
      "question": "What does the Single Responsibility Principle mean?",
      "options": [
        { "type": "text", "value": "Classes should have only one method" },
        { "type": "text", "value": "Classes should have only one constructor" },
        { "type": "text", "value": "Classes should focus on one area of responsibility" },
        { "type": "text", "value": "Classes should have only one instance variable" }
      ],
      "answer": 2,
      "explanation": "Classes should have a single, focused responsibility; unrelated functionality should be in separate classes."
    },
    {
      "id": 13,
      "type": "text",
      "question": "Why validate data in setters?",
      "options": [
        { "type": "text", "value": "To make code slower" },
        { "type": "text", "value": "It's not necessary" },
        { "type": "text", "value": "To maintain object invariants and prevent invalid states" },
        { "type": "text", "value": "To eliminate getters" }
      ],
      "answer": 2,
      "explanation": "Validation in setters ensures objects maintain valid states and enforces business rules."
    },
    {
      "id": 14,
      "type": "text",
      "question": "How can you protect against null references?",
      "options": [
        { "type": "text", "value": "Ignore them" },
        { "type": "text", "value": "Check for null before accessing methods or fields" },
        { "type": "text", "value": "Use only primitive types" },
        { "type": "text", "value": "Avoid creating objects" }
      ],
      "answer": 1,
      "explanation": "Always check if references are null before accessing them to prevent NullPointerException."
    },
    {
      "id": 15,
      "type": "text",
      "question": "What is defensive copying?",
      "options": [
        { "type": "text", "value": "Deleting copies" },
        { "type": "text", "value": "Returning copies of mutable objects instead of direct references" },
        { "type": "text", "value": "Preventing object creation" },
        { "type": "text", "value": "Copying constructors" }
      ],
      "answer": 1,
      "explanation": "Defensive copying returns clones of mutable objects to protect internal state from external modification."
    },
    {
      "id": 16,
      "type": "text",
      "question": "What is the benefit of learning common mistakes?",
      "options": [
        { "type": "text", "value": "To make programs slower" },
        { "type": "text", "value": "To avoid frustration and write better, more professional code" },
        { "type": "text", "value": "To eliminate all errors" },
        { "type": "text", "value": "To reduce class size" }
      ],
      "answer": 1,
      "explanation": "Learning common mistakes helps you avoid frustration, write better code, and accelerate your mastery of OOP."
    }
  ]
}