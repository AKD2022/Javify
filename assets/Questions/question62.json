{
  "lessonId": 62,
  "title": "Off-by-One Errors and Common Bugs",
  "questions": [
    {
     "id": 1,
      "type": "text",
      "question": "What is an off-by-one error?",
      "options": [
        { "type": "text", "value": "When a loop iterates one time too many or too few" },
        { "type": "text", "value": "When you forget a semicolon" },
        { "type": "text", "value": "When variables have wrong names" },
        { "type": "text", "value": "When loops run too fast" }
      ],
      "answer": 0,
      "explanation": "An off-by-one error occurs when a loop iterates one time too many or one time too few, processing incorrect data or missing important values."
    },
    {
      "id": 2,
      "type": "text",
      "question": "What is the most common cause of off-by-one errors?",
      "options": [
        { "type": "text", "value": "Using too many variables" },
        { "type": "text", "value": "Confusing < with <=" },
        { "type": "text", "value": "Forgetting semicolons" },
        { "type": "text", "value": "Using wrong data types" }
      ],
      "answer": 1,
      "explanation": "Confusing < with <= (or > with >=) is the most frequent cause of off-by-one errors in counting loops."
    },
    {
      "id": 3,
      "type": "code",
      "question": "What's wrong with this loop for a 5-element array?\n\nint[] numbers = {10, 20, 30, 40, 50};\nfor (int i = 0; i < 4; i++) {\n    System.out.println(numbers[i]);\n}",
      "options": [
        { "type": "text", "value": "Misses the last element at index 4" },
        { "type": "text", "value": "Nothing is wrong" },
        { "type": "text", "value": "Prints too many elements" },
        { "type": "text", "value": "Starts at wrong index" }
      ],
      "answer": 0,
      "explanation": "The condition i < 4 processes indices 0-3, missing the last element at index 4. Should be i < 5 or i < numbers.length."
    },
    {
      "id": 4,
      "type": "text",
      "question": "What index should array loops typically start at?",
      "options": [
        { "type": "text", "value": "1" },
        { "type": "text", "value": "2" },
        { "type": "text", "value": "-1" },
        { "type": "text", "value": "0" }
      ],
      "answer": 3,
      "explanation": "Arrays in Java are zero-indexed, so array loops should typically start at index 0 unless you have a specific reason to skip elements."
    },
    {
      "id": 5,
      "type": "code",
      "question": "What's wrong with this counting loop?\n\nfor (int i = 1; i < 10; i++) {\n    System.out.println(i);\n}",
      "options": [
        { "type": "text", "value": "Only counts to 9 instead of 10" },
        { "type": "text", "value": "Counts too high" },
        { "type": "text", "value": "Nothing is wrong" },
        { "type": "text", "value": "Starts at wrong number" }
      ],
      "answer": 0,
      "explanation": "The condition i < 10 stops at 9. If counting to 10 inclusive is intended, should use i <= 10."
    },
    {
      "id": 6,
      "type": "code",
      "question": "What happens with this loop?\n\nString text = \"Hello\";\nfor (int i = 0; i <= text.length(); i++) {\n    System.out.println(text.charAt(i));\n}",
      "options": [
        { "type": "text", "value": "Works perfectly" },
        { "type": "text", "value": "Index out of bounds error at i=5" },
        { "type": "text", "value": "Misses first character" },
        { "type": "text", "value": "Prints nothing" }
      ],
      "answer": 1,
      "explanation": "\"Hello\" has length 5 but valid indices 0-4. Using i <= text.length() tries to access index 5, causing an error. Should use i < text.length()."
    },
    {
      "id": 7,
      "type": "text",
      "question": "What is the formula for counting numbers in an inclusive range from start to end?",
      "options": [
        { "type": "text", "value": "end - start" },
        { "type": "text", "value": "end + start" },
        { "type": "text", "value": "end * start" },
        { "type": "text", "value": "end - start + 1" }
      ],
      "answer": 3,
      "explanation": "The formula is end - start + 1 for inclusive ranges. From 1 to 10 contains 10 - 1 + 1 = 10 numbers. Forgetting the +1 is a classic mistake."
    },
    {
      "id": 8,
      "type": "code",
      "question": "What's wrong with this countdown loop if 0 should be included?\n\nfor (int i = 5; i > 0; i--) {\n    System.out.println(i);\n}",
      "options": [
        { "type": "text", "value": "Nothing wrong" },
        { "type": "text", "value": "Counts up instead of down" },
        { "type": "text", "value": "Counts too high" },
        { "type": "text", "value": "Stops at 1, doesn't include 0" }
      ],
      "answer": 3,
      "explanation": "The condition i > 0 stops at 1, missing 0. If 0 should be included, use i >= 0."
    },
    {
      "id": 9,
      "type": "text",
      "question": "What should you always test to catch off-by-one errors?",
      "options": [
        { "type": "text", "value": "Boundary values like first element, last element, and empty collections" },
        { "type": "text", "value": "Only middle values" },
        { "type": "text", "value": "Only large arrays" },
        { "type": "text", "value": "Random values" }
      ],
      "answer": 0,
      "explanation": "Always test boundary values like first element, last element, and empty collections to catch off-by-one errors quickly."
    },
    {
      "id": 10,
      "type": "code",
      "question": "What is the correct pattern for iterating over any array?\n\nint[] data = {10, 20, 30};",
      "options": [
        { "type": "text", "value": "for (int i = 1; i <= data.length; i++)" },
        { "type": "text", "value": "for (int i = 0; i < data.length; i++)" },
        { "type": "text", "value": "for (int i = 0; i <= data.length; i++)" },
        { "type": "text", "value": "for (int i = 1; i < data.length; i++)" }
      ],
      "answer": 1,
      "explanation": "The pattern i < array.length works for any array size, starting at 0 and stopping before length, covering valid indices 0 to length-1."
    },
    {
      "id": 11,
      "type": "text",
      "question": "What's the difference between array.length and string.length()?",
      "options": [
        { "type": "text", "value": "They're the same" },
        { "type": "text", "value": "length() is faster" },
        { "type": "text", "value": "array.length is a property, string.length() is a method" },
        { "type": "text", "value": "Arrays can't use length" }
      ],
      "answer": 2,
      "explanation": "Arrays use .length (property) while Strings use .length() (method). Remember the parentheses for strings."
    },
    {
      "id": 12,
      "type": "code",
      "question": "What problem does this nested loop have for a 3×3 grid?\n\nfor (int row = 0; row < 3; row++) {\n    for (int col = 0; col < 4; col++) {\n        System.out.print(\"* \");\n    }\n}",
      "options": [
        { "type": "text", "value": "Creates 3×4 rectangle instead of 3×3 grid" },
        { "type": "text", "value": "Nothing wrong" },
        { "type": "text", "value": "Too few rows" },
        { "type": "text", "value": "Wrong starting index" }
      ],
      "answer": 0,
      "explanation": "The column loop runs 4 times instead of 3, creating a 3×4 rectangle. Should be col < 3 for a 3×3 grid."
    },
    {
      "id": 13,
      "type": "text",
      "question": "When should you use <= instead of <?",
      "options": [
        { "type": "text", "value": "Always" },
        { "type": "text", "value": "Never" },
        { "type": "text", "value": "When you want to include the boundary value" },
        { "type": "text", "value": "Only with arrays" }
      ],
      "answer": 2,
      "explanation": "Use <= when you want to include the boundary value in your loop. Use < when you want to stop before the boundary."
    },
    {
      "id": 14,
      "type": "text",
      "question": "What debugging questions help identify off-by-one errors?",
      "options": [
        { "type": "text", "value": "Does it start/end at right index, process all elements, skip any?" },
        { "type": "text", "value": "Is it fast enough?" },
        { "type": "text", "value": "Does it use enough variables?" },
        { "type": "text", "value": "Is the name good?" }
      ],
      "answer": 0,
      "explanation": "Ask: Does it start at the right index? End at the right index? Process all elements? Skip or duplicate any? These questions reveal off-by-one errors."
    },
    {
      "id": 15,
      "type": "code",
      "question": "What's wrong if this skips the first element?\n\nint[] values = {5, 10, 15, 20};\nfor (int i = 1; i < values.length; i++) {\n    System.out.println(values[i]);\n}",
      "options": [
        { "type": "text", "value": "Starts at index 1 instead of 0" },
        { "type": "text", "value": "Wrong condition" },
        { "type": "text", "value": "Wrong increment" },
        { "type": "text", "value": "Nothing wrong" }
      ],
      "answer": 0,
      "explanation": "Starting at i = 1 skips the first element at index 0. Should start at i = 0 to include all elements."
    },
    {
      "id": 16,
      "type": "text",
      "question": "How can drawing out examples help prevent off-by-one errors?",
      "options": [
        { "type": "text", "value": "It can't help" },
        { "type": "text", "value": "It wastes time" },
        { "type": "text", "value": "It makes code slower" },
        { "type": "text", "value": "It helps visualize whether boundary values should be included or excluded" }
      ],
      "answer": 3,
      "explanation": "Drawing out small examples helps visualize whether boundary values should be included or excluded, making the correct condition obvious."
    }
  ]
}