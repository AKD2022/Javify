{
  "lessonId": 72,
  "title": "Using this to Reference Instance Variables",
  "questions": [
    {
      "id": 1,
      "type": "text",
      "question": "What does the keyword this refer to?",
      "options": [
        { "type": "text", "value": "The current object" },
        { "type": "text", "value": "The class definition" },
        { "type": "text", "value": "A static variable" },
        { "type": "text", "value": "The main method" }
      ],
      "answer": 0,
      "explanation": "The this keyword refers to the current objectâ€”the specific instance on which a method is being executed."
    },
    {
      "id": 2,
      "type": "text",
      "question": "What is the main purpose of using this with instance variables?",
      "options": [
        { "type": "text", "value": "To make code run faster" },
        { "type": "text", "value": "To disambiguate between parameters and instance variables with the same name" },
        { "type": "text", "value": "To delete variables" },
        { "type": "text", "value": "To create new objects" }
      ],
      "answer": 1,
      "explanation": "Using this.variableName clarifies that you're referring to an instance variable, not a parameter or local variable with the same name."
    },
    {
      "id": 3,
      "type": "text",
      "question": "What is variable shadowing?",
      "options": [
        { "type": "text", "value": "When a variable is deleted" },
        { "type": "text", "value": "When a local variable or parameter hides an instance variable with the same name" },
        { "type": "text", "value": "When a variable changes type" },
        { "type": "text", "value": "When two variables are in different classes" }
      ],
      "answer": 1,
      "explanation": "Shadowing occurs when a local variable or parameter has the same name as an instance variable, causing the local one to be used instead."
    },
    {
      "id": 4,
      "type": "text",
      "question": "In a constructor with parameters named the same as instance variables, what does using this accomplish?",
      "options": [
        { "type": "text", "value": "Creates duplicate variables" },
        { "type": "text", "value": "Prevents variable shadowing and clearly assigns parameters to instance variables" },
        { "type": "text", "value": "Deletes the parameters" },
        { "type": "text", "value": "Makes the constructor slower" }
      ],
      "answer": 1,
      "explanation": "Using this in constructors ensures parameters are assigned to instance variables and prevents the common bug of parameters shadowing instance variables."
    },
    {
      "id": 5,
      "type": "text",
      "question": "Can you use this to call methods on the current object?",
      "options": [
        { "type": "text", "value": "No, this only works with variables" },
        { "type": "text", "value": "Yes, using this.methodName() calls the method on the current object" },
        { "type": "text", "value": "Only in static methods" },
        { "type": "text", "value": "Only in constructors" }
      ],
      "answer": 1,
      "explanation": "You can use this to explicitly call methods on the current object: this.methodName() makes it clear the method belongs to this instance."
    },
    {
      "id": 6,
      "type": "text",
      "question": "When are parameters shadowed by instance variables?",
      "options": [
        { "type": "text", "value": "Always" },
        { "type": "text", "value": "Never" },
        { "type": "text", "value": "When they share the same name" },
        { "type": "text", "value": "Only in static methods" }
      ],
      "answer": 2,
      "explanation": "Parameters shadow (hide) instance variables when they share the same name, causing the parameter to be used by default."
    },
    {
      "id": 7,
      "type": "text",
      "question": "What happens without this if a parameter has the same name as an instance variable?",
      "options": [
        { "type": "text", "value": "Both refer to the same thing" },
        { "type": "text", "value": "The parameter is used by default, potentially leaving the instance variable uninitialized" },
        { "type": "text", "value": "A compilation error occurs" },
        { "type": "text", "value": "The instance variable is automatically initialized" }
      ],
      "answer": 1,
      "explanation": "Without this, the parameter shadows the instance variable, so assignments might go to the parameter instead of the instance variable."
    },
    {
      "id": 8,
      "type": "text",
      "question": "Is using this optional when no shadowing occurs?",
      "options": [
        { "type": "text", "value": "No, it is always required" },
        { "type": "text", "value": "Yes, but it is still good practice for clarity" },
        { "type": "text", "value": "Yes, and should never be used" },
        { "type": "text", "value": "Only in constructors" }
      ],
      "answer": 1,
      "explanation": "While technically optional when there's no shadowing, using this consistently improves code clarity and makes intentions explicit."
    },
    {
      "id": 9,
      "type": "text",
      "question": "In what context is this particularly important to use?",
      "options": [
        { "type": "text", "value": "In static methods" },
        { "type": "text", "value": "In constructors where parameters match instance variable names" },
        { "type": "text", "value": "When creating arrays" },
        { "type": "text", "value": "In primitive type declarations" }
      ],
      "answer": 1,
      "explanation": "Using this is especially critical in constructors because parameters typically share names with instance variables."
    },
    {
      "id": 10,
      "type": "text",
      "question": "What does this.variableName = variableName accomplish in a constructor?",
      "options": [
        { "type": "text", "value": "Creates a new variable" },
        { "type": "text", "value": "Assigns the parameter value to the instance variable" },
        { "type": "text", "value": "Deletes the parameter" },
        { "type": "text", "value": "Creates a duplicate" }
      ],
      "answer": 1,
      "explanation": "this.variableName = variableName assigns the parameter (right side) to the instance variable (left side), properly initializing the object."
    },
    {
      "id": 11,
      "type": "text",
      "question": "What is a common bug that this helps prevent?",
      "options": [
        { "type": "text", "value": "Infinite loops" },
        { "type": "text", "value": "Parameters assigning to themselves instead of instance variables" },
        { "type": "text", "value": "Array index out of bounds" },
        { "type": "text", "value": "Null pointer exceptions" }
      ],
      "answer": 1,
      "explanation": "Without this, a constructor might accidentally write variableName = variableName, assigning a parameter to itself and leaving instance variables uninitialized."
    },
    {
      "id": 12,
      "type": "text",
      "question": "Can you access instance variables without using this?",
      "options": [
        { "type": "text", "value": "No, this is always required" },
        { "type": "text", "value": "Yes, but only if they don't share names with parameters" },
        { "type": "text", "value": "Only in static methods" },
        { "type": "text", "value": "Only in main method" }
      ],
      "answer": 1,
      "explanation": "You can access instance variables without this if no parameter or local variable shadows them, but shadowing makes this necessary."
    },
    {
      "id": 13,
      "type": "text",
      "question": "What coding practice does professional Java code typically follow?",
      "options": [
        { "type": "text", "value": "Never use this" },
        { "type": "text", "value": "Use this only when absolutely necessary" },
        { "type": "text", "value": "Always use this explicitly when accessing instance variables" },
        { "type": "text", "value": "Use this only in main method" }
      ],
      "answer": 2,
      "explanation": "Professional Java code almost always uses this explicitly when accessing instance variables for clarity and consistency."
    },
    {
      "id": 14,
      "type": "text",
      "question": "How does this improve code readability?",
      "options": [
        { "type": "text", "value": "It doesn't; it just adds extra text" },
        { "type": "text", "value": "It makes it immediately clear which variables are instance variables" },
        { "type": "text", "value": "It shortens the code" },
        { "type": "text", "value": "It speeds up compilation" }
      ],
      "answer": 1,
      "explanation": "Using this consistently makes it immediately obvious to anyone reading the code that they're accessing instance variables, not local variables."
    },
    {
      "id": 15,
      "type": "text",
      "question": "Can you use this to access variables in a different object?",
      "options": [
        { "type": "text", "value": "Yes, this works on any object" },
        { "type": "text", "value": "No, this refers only to the current object" },
        { "type": "text", "value": "Only if using static" },
        { "type": "text", "value": "Only in constructors" }
      ],
      "answer": 1,
      "explanation": "The this keyword refers only to the current object; to access another object's variables, you use that object's reference directly."
    },
    {
      "id": 16,
      "type": "text",
      "question": "What is the scope of this?",
      "options": [
        { "type": "text", "value": "The entire program" },
        { "type": "text", "value": "Only within methods and constructors of the class" },
        { "type": "text", "value": "Only in the main method" },
        { "type": "text", "value": "Only for primitive types" }
      ],
      "answer": 1,
      "explanation": "The this keyword is valid only within methods and constructors of the class, referring to the instance currently executing."
    }
  ]
}